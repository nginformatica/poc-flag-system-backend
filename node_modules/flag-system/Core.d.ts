import type { ApiResponse, Entity, FeatureCollisionReturn, FeatureInstance, FeatureValidationReturn, FlagSysCallbacks, IFlags, InterfaceWithId, Method, Priority, PurgeFeatureReturn, PurgeFlagMethod, RelatedFlagReturn, UpdateFeatureVersionReturn } from './Types';
import { FeatureVersion } from './Types';
export default abstract class Core<Flag, Feature, FlagInterface extends IFlags<Flag>> {
    /**
     * An object containing callback functions for the Flag System.
     * @typeparam Flag Type of system flags.
     * @typeparam Feature Type of features.
     */
    protected readonly cb: FlagSysCallbacks<Flag, Feature, FlagInterface>;
    /**
     * Indicates whether the system is running in development mode.
     */
    protected readonly isDev: boolean;
    /**
     * A flag that indicates whether the system is running in debug mode.
     */
    protected isDebugMode: boolean;
    /**
     * The default version of a feature.
     */
    protected readonly defaultVersion: FeatureVersion;
    constructor(
    /**
     * An object containing callback functions for the Flag System.
     * @typeparam Flag Type of system flags.
     * @typeparam Feature Type of features.
     */
    cb: FlagSysCallbacks<Flag, Feature, FlagInterface>, 
    /**
     * Indicates whether the system is running in development mode.
     */
    isDev?: boolean, 
    /**
     * A flag that indicates whether the system is running in debug mode.
     */
    isDebugMode?: boolean);
    /**
     * Determines whether the user is allowed to access the specified feature.
     * @param feature The feature to check.
     * @param flagsData The flags data object to check.
     * @returns A promise that resolves with object containing a boolean
     * indicating whether the user is allowed to access the feature and the
     * version of the feature.
     */
    protected isAllowed(feature: Feature, flagsData: FlagInterface): Promise<FeatureValidationReturn>;
    /**
     * Returns the correct version for a feature.
     * @param userVersion The version of the feature for the user.
     * @param orgVersion The version of the feature for the organization.
     * @param permissive A flag that indicates whether the organization is
     * permissive.
     * @returns The correct version for the feature.
     */
    protected getFeatureVersion(userVersion: FeatureVersion, orgVersion: FeatureVersion, permissive: boolean): FeatureVersion;
    /**
     * Removes duplicated items from an array.
     * @param list - The array to remove duplicates from.
     * @returns - The array with duplicates removed.
     */
    protected removeDuplicated<T>(array: T[]): T[];
    /**
     * Returns information about collected about the system.
     * @returns A promise that resolves with an array containing information
     * about the system.
     */
    protected debug(): Promise<unknown[][]>;
    /**
     * Gets all interfaces from the system.
     * @returns A promise that resolves with an array containing all interfaces
     * from the system.
     * @throws {CallbacksNotDefinedError} If the `getAllUsersInterfaces` or
     * `getAllOrganizationsInterfaces` callbacks are not defined.
     */
    protected getAllInterfaces(): Promise<Array<InterfaceWithId<FlagInterface>>>;
    /**
     * Gets the interface of a organization.
     * @param userId The ID of the user that belongs to the organization.
     * @returns A promise that resolves with the organization interface of the
     * user.
     * @throws {CallbacksNotDefinedError} If the
     * `getOrganizationInterfaceFromUserId` callback is not defined.
     */
    protected getUserOrganization(userId: string): Promise<FlagInterface>;
    /**
     * Gets the interface of a user.
     * @param userId The ID of the user.
     * @returns A promise that resolves with the user interface.
     * @throws {CallbacksNotDefinedError} If the `getOrganizationInterface`
     * callback is not defined.
     */
    protected getUser(userId: string): Promise<FlagInterface>;
    protected coreFlagEntity(entityId: string, flag: Flag | Flag[], entity: Entity, method: Method): Promise<Flag[]>;
    /**
     * Removes the provided flag from the system.
     * @param flag - The flag to remove.
     * @returns - A promise that resolves when the flag has been removed.
     * @throws {CallbacksNotDefinedError} If the removeFlag callback is not
     * defined.
     */
    protected removeFlag(flag: Flag): Promise<Flag>;
    /**
     * Purges a flag from the system.
     * @param flag - Flag to purge. Can be an array of flags or a single flag.
     * @returns - A promise that resolves when the flag has been purged.
     * @throws {CallbacksNotDefinedError} If the removeFlag callback is not
     * defined.
     * @throws {CallbacksNotDefinedError} If the getAllUsersInterfaces callback
     * is not defined.
     * @throws {CallbacksNotDefinedError} If the getAllOrganizationInterfaces
     * callback is not defined.
     */
    protected corePurgeFlag(flag: Flag | Flag[], method: PurgeFlagMethod): Promise<Flag[]>;
    readonly enableDebugMode: () => void;
    protected coreCanUserAccessFeature(userId: string, feature: Feature): Promise<FeatureValidationReturn>;
    protected coreRegisterFlag(flag: Flag, priority: Priority, features: Array<FeatureInstance<Feature>>): Promise<Flag>;
    protected coreUpdateFlag(flag: Flag, priority: Priority, features: Array<FeatureInstance<Feature>>, featureOperator: Method): Promise<Flag>;
    protected coreFindFlagsRelatedToFeature(feature: Feature): Promise<Array<RelatedFlagReturn<Flag>>>;
    protected coreUpdateFeatureVersion(feature: Feature, version: FeatureVersion, flag: Flag): Promise<UpdateFeatureVersionReturn<Feature, Flag>>;
    protected coreFindFloatingFeatures(sysFeatures: Feature[]): Promise<Feature[]>;
    protected corePurgeFeature(feature: Feature | Feature[]): Promise<PurgeFeatureReturn<Flag>>;
    protected coreFindFloatingFlags(sysFlags: Flag[]): Promise<Flag[]>;
    protected coreFindFeaturesRelatedToFlag(flag: Flag): Promise<Array<FeatureInstance<Feature>>>;
    protected coreFindAnyFeatureCollision(): Promise<Array<FeatureCollisionReturn<Feature, Flag>>>;
    protected handler<T>(res: () => Promise<T>): Promise<ApiResponse<T>>;
}
